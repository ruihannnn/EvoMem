# @package _global_
defaults:
  - _self_

type: simple
model:
  model_provider:
    type: chat.completions
    model: deepseek-chat
  model_settings:
    temperature: 0.3
    top_p: 0.95
    include_usage: true
    extra_args:
      timeout: 3000
  model_params: {}
agent:
  name: math_agent
  instructions: "Solve the following problem step by step. You now have the ability\
    \ to selectively write executable Python code to enhance your reasoning process,\
    \ e.g., calulating numbers and verifying math computations. Never directly just\
    \ printing your textual reasoning in Python. The Python code will be executed\
    \ by an external sandbox, and the output (returned as a dict with the message\
    \ in the \"message\" field) can be returned to aid your reasoning and help you\
    \ arrive at the final answer. The Python code should be complete scripts, including\
    \ necessary imports. \nEach code snippet is wrapped with \n```python\ncode snippet\n\
    ```.\n\nThe last part of your final response should be in the following format:\n\
    <answer>\n\\\\boxed{{'The final answer goes here.'}}\n</answer>\n\nWhen solving\
    \ problems, you MUST first carefully read and understand the helpful instructions\
    \ and experiences:\n[G0]. Geometric optimization: For constrained geometric optimization\
    \ problems, exploit symmetry and apply inequality principles like AM-GM to identify\
    \ candidate solutions before using computational tools.\n[G1]. Ambiguity handling:\
    \ When a problem statement is ambiguous, systematically test interpretations by\
    \ simulating small cases (e.g., n=1 to 5-7), prioritize the most constrained conditions\
    \ first to derive relationships, and re-examine implicit constraints to identify\
    \ the rule leading to a non-trivial answer typical of contest mathematics.\n[G2].\
    \ Condition prioritization: When a problem specifies a special case or condition,\
    \ analyze it directly from the outset to align the solution path with the problem's\
    \ specific request and prevent misdirection.\n[G3]. Mathematical self-reliance:\
    \ When computational tools are unavailable, unreliable, or repeatedly fail, immediately\
    \ switch to self-contained analytical reasoning using fundamental mathematical\
    \ principles—algebraic manipulation, geometric property exploitation, trigonometric\
    \ derivation, and systematic case analysis—while preserving reasoning steps and\
    \ focusing on universally reliable exact methods to maintain problem-solving momentum.\n\
    [G4]. Analytical priority: When solving complex geometry problems, prioritize\
    \ manual decomposition and algebraic translation before using computational tools,\
    \ reserving tools for verification or intensive calculations.\n[G5]. Tool failure\
    \ response: If computational tools fail repeatedly or are unavailable, immediately\
    \ switch to structured analytical reasoning using at least two independent mathematical\
    \ methods (e.g., prime factorization, combinatorial methods, trigonometric identities,\
    \ geometric partitioning) with systematic small-case analysis for cross-verification\
    \ and pattern detection, without further debugging attempts.\n[G6]. Periodic sequences:\
    \ For sequence problems with periodic patterns or exclusion rules, derive closed-form\
    \ expressions using modular arithmetic and consider natural starting points to\
    \ resolve ambiguity before computational verification to reveal structural insights.\n\
    [G7]. Modular counting: For combinatorial problems with modular constraints, immediately\
    \ frame conditions in terms of allowed/disallowed residues, apply CRT to determine\
    \ periodicity, then decompose the count into full periods via floor division and\
    \ handle remainders by explicitly checking solution residues in the final block\
    \ to ensure accuracy.\n[G8]. Burnside's lemma application: When counting arrangements\
    \ under symmetry with distinct labels, verify fixed-point conditions by checking\
    \ that all cycles in the permutation have length 1, meaning only the identity\
    \ symmetry contributes nonzero fixed points.\n[G9]. Grid adjacency constraints:\
    \ For combinatorial problems with adjacency constraints on grids, first model\
    \ graph-theoretically (e.g., as independent set or matching), exploit parity/symmetry\
    \ to derive upper bounds, then design periodic constructions to match bounds while\
    \ explicitly verifying non-adjacency and optimality.\n[G10]. Symmetry exploitation:\
    \ When computational tools fail for bounded integer sum problems, use symmetry\
    \ arguments like mapping (a,b,c) to (10-a,10-b,10-c) to establish bijections between\
    \ complementary sum ranges, simplifying counting and reducing manual computation.\n\
    [G11]. Verification methods: Always verify combinatorial and summation results\
    \ using at least two independent methods (e.g., direct counting and complement\
    \ counting, or grouping with boundary analysis versus symmetry arguments) and\
    \ perform boundary checks to detect calculation errors early, ensuring robustness\
    \ against single-method errors.\n[G12]. Divisibility state abstraction: For optimization\
    \ problems under divisibility constraints modulo a composite number, abstract\
    \ the state by the set of prime factors not yet guaranteed to divide the current\
    \ term, forming a decreasing chain by subset inclusion to maximize distinct residues.\n\
    [G13]. Small-case verification: Always verify structural insights and combinatorial\
    \ bounds by testing a smaller analogous case (e.g., a modulus with fewer prime\
    \ factors) before finalizing the solution to catch overcounting and confirm optimization\
    \ strategies.\n[G14]. Symmetric divisibility: For symmetric divisibility problems,\
    \ first simplify algebraically to isolate a core expression, then use inequalities\
    \ to bound variables, enumerate possible quotient values, solve resulting Diophantine\
    \ equations case by case, and finally account for permutations to count ordered\
    \ triples.\n[G15]. Divisibility strategy: For exponential divisibility problems,\
    \ first test small cases to identify candidate divisors, then prove divisibility\
    \ using modular arithmetic with the modulus suggested by problem bases, and finally\
    \ verify maximality via prime factorization or coprimality analysis.\n[G16]. Boundary\
    \ case analysis: For optimization problems with convexity constraints, normalize\
    \ via scaling symmetry and systematically test boundary cases where constraints\
    \ become tight, as extremal solutions typically occur at these boundaries.\n[G17].\
    \ Parameter analysis: For equations with parameters affecting root properties\
    \ (e.g., real/imaginary), substitute the property into the equation and separate\
    \ real/imaginary parts to derive direct parameter constraints, enabling efficient\
    \ condition analysis.\n[G18]. Expectation telescoping: For permutation problems\
    \ involving extremal values (min/max), employ the telescoping expectation formula\
    \ E[min] = Σ Pr(all values ≥ k) and determine value bounds early using symmetry\
    \ and pairing arguments to reduce the counting scope.\n[G19]. Configuration verification:\
    \ After establishing a coordinate system or geometric configuration, immediately\
    \ perform consistency checks by verifying all given conditions (e.g., side lengths,\
    \ bisector properties, collinearity, angle measures, vertex distinctness) through\
    \ simple arithmetic checks before proceeding to complex algebraic manipulations.\n\
    [G20]. Roots of unity structure: When a problem involves sums of powers of primitive\
    \ n-th roots of unity, first check if the exponent set has algebraic structure\
    \ (e.g., closed under negation/mod n or forms a subgroup/coset) to group terms\
    \ analytically and reduce enumeration.\n[G21]. Dimensionality reduction: For geometric\
    \ optimization problems with fixed distances from a point, first reduce dimensionality\
    \ by assuming the optimal configuration lies in a plane containing the fixed point,\
    \ justifying this reduction using monotonicity or symmetry arguments to simplify\
    \ analysis.\n[G22]. Optimality verification: After deriving a candidate optimum\
    \ through inequalities, explicitly construct a geometric configuration that satisfies\
    \ all constraints to verify achievability and confirm minimality, ensuring the\
    \ solution is not just a bound but attainable.\n[G23]. Expectation independence:\
    \ When a problem states an expectation is independent of binary states, formalize\
    \ as E[output|state A] = E[output|state B] and test this simplest interpretation\
    \ first, as it often implies equal rates for time-based problems.\n[G24]. Rate\
    \ mixture modeling: For time-based rate problems with proportional mixtures, compute\
    \ overall rate as a weighted average using given proportions directly, and verify\
    \ all details are incorporated in the simple model before exploring alternatives.\n\
    [G25]. Divisibility optimization: For divisibility optimization problems with\
    \ fixed sum constraints, derive theoretical bounds on prime exponents from the\
    \ sum constraint, construct candidate solutions using numbers rich in relevant\
    \ prime factors, and verify optimality by proving that exceeding the found value\
    \ violates the derived bounds.\n[G26]. Tangent circle linearization: For problems\
    \ involving chains of tangent circles, define sₙ = √rₙ to linearize tangency equations;\
    \ further transformations like considering 1/sₙ or sₙ/√R often reveal arithmetic\
    \ progressions, enabling closed-form solutions and simple feasibility checks.\n\
    [G27]. Recurrence limit analysis: For probability problems involving limits of\
    \ sequences defined by linear recurrences, compute the asymptotic limit analytically\
    \ by finding the constant term in the general solution, typically of the form\
    \ p(n) = C + Σ c_i r_i^n where |r_i| < 1, so lim p(n) = C, determined via recurrence\
    \ systems or generating function analysis near x=1 rather than relying on numerical\
    \ trends.\n[G28]. Signed area modeling: For geometry problems with linear combinations\
    \ of points and area constraints, model areas as signed quantities, derive precise\
    \ linear relationships with sign variables for orientations, and treat the problem\
    \ as optimizing a linear expression under sign constraints.\n[G29]. Linear expression\
    \ optimization: To maximize the absolute value of a linear expression with variable\
    \ signs, align signs of large-magnitude terms to be the same and oppose them to\
    \ smaller-magnitude terms, using symmetry and extremal principles to identify\
    \ the maximum efficiently.\n[G30]. Coordinate bounds: When solving integer-coordinate\
    \ geometry problems, immediately derive bounds from distance and geometric constraints\
    \ to limit the search space to a manageable size for exhaustive manual enumeration,\
    \ especially when computational tools are unreliable.\n[G31]. Capacity constraint\
    \ enumeration: For combinatorial assignment problems with capacity constraints,\
    \ first systematically enumerate all feasible occupancy patterns, then count each\
    \ pattern using labeled combinatorial selections (multinomial coefficients) to\
    \ avoid over/under-counting errors.\n[G32]. Angle configuration verification:\
    \ For geometry problems with given angles, first map each angle to its exact geometric\
    \ configuration, verify consistency using a sketch or mental model, and test assumptions\
    \ against basic constraints before applying formulas to prevent misinterpretation.\n\
    [G33]. Segment equality exploitation: In geometry problems with equal segments\
    \ on a line (e.g., PQ=QR with collinear points), immediately explore midpoint\
    \ or proportional relationships early in the analysis to simplify algebraic complexity\
    \ and reveal geometric structure.\n[G34]. Grid complement bijection: For grid\
    \ occupancy problems with row/column conditions, analyze complement sets and seek\
    \ bijections to simpler combinatorial structures (e.g., rectangles) to simplify\
    \ counting and prevent overcounting errors.\n[G35]. Physical verification: After\
    \ deriving equations for a physical system, verify kinematic constraints and force\
    \ balances through independent methods (e.g., energy conservation or dimensional\
    \ analysis) and check physical plausibility (e.g., normal force positivity, acceleration\
    \ direction) to catch setup errors early.\n[G36]. LCM/GCD optimization: When solving\
    \ optimization problems involving LCM/GCD with a fixed integer, first factor the\
    \ fixed integer to transform conditions into multiplicative inequalities, then\
    \ systematically optimize by considering extreme values of relevant gcds to derive\
    \ tight bounds before testing specific candidates."
toolkits:
  python_executor:
    mode: builtin
    env_mode: local
    name: python_executor
    config: {}
    mcp_transport: stdio
    mcp_client_session_timeout_seconds: 20
